<!DOCTYPE html>
<html>
<head>
  <title>Javascript Pro</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <style type="text/css">
   @import url('https://fonts.googleapis.com/css?family=Montserrat:300,400,600,800,900');
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
    body { font-family: 'Montserrat'; }
    h1, h2, h3 {
      font-family: 'Montserrat';
      font-weight: 400;
    }
    .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    .remark-slide-content{background: transparent;}
    .remark-slide {
      background: #002244ff center center no-repeat;
      background-size: cover;
      color: #ffffff;
    }
    .remark-slide-number{color: #fff;font-size: 1rem;font-weight: bold;}

    .remark-slide-content h1 {
        font-size: 2.2rem;
    }

    .remark-slide-content h2 {
        font-size: 1.9rem;
    }
    .remark-slide-content h3 {
        font-size: 1.4rem;
    }
    a, a:link, a:visited, a:hover, a:active{
        color: #007FFF;
    }

  </style>
</head>
<body>
  <textarea id="source" style="display:none;">

    class: center, middle

    # Javascript Pro

    <br/><img src="https://raw.githubusercontent.com/cerebrobr/adesivos/master/view/javascript.png" title="Javascript Pro" alt="Javascript Pro logo" style="max-height: 200px;clear: both;float: none;" />
    


    ---
    class: center, middle
    # Javascript - Definição de alto nível
 
    ---
    # Javascript - Definição de alto nível

    JavaScript é uma linguagem de programação que permite a você implementar itens complexos em páginas web — toda vez que uma página da web faz mais do que simplesmente mostrar a você informação estática — mostrando conteúdo que se atualiza em um intervalo de tempo, mapas interativos ou gráficos 2D/3D animados, etc. — você pode apostar que o JavaScript provavelmente está envolvido. 

    É a terceira camada do bolo das tecnologias padrões da web.

    <br/><img src="https://mdn.mozillademos.org/files/13502/cake.png" title="Javascript Pro" alt="Javascript Pro logo" style="max-height: 200px;clear: both; float: none;margin: 0px auto;" />
    
    ---
    # Javascript   

    - HTML é a linguagem de marcação que nós usamos para estruturar e dar significado para o nosso conteúdo web, por exemplo, definindo parágrafos, cabeçalhos, tabelas de conteúdo, ou inserindo imagens e vídeos na página.
    - CSS é uma linguagem de regras de estilo que nós usamos para aplicar estilo ao nosso conteúdo HTML, por exemplo, definindo cores de fundo e fontes, e posicionando nosso conteúdo em múltiplas colunas.
    - JavaScript é uma linguagem de programação que permite a você criar conteúdo que se atualiza dinamicamente, controlar múltimídias, imagens animadas, e tudo o mais que há de intessante. Ok, não tudo, mas é maravilhoso o que você pode efetuar com algumas linhas de código JavaScript.

    ---
    # Javascript

    ## Então o que ele pode realmente fazer?

    O núcleo da linguagem JavaScript consiste em alguns benefícios comuns da programação que permite a você fazer coisas como:

    - Armazenar conteúdo útil em variáveis.
    - Operações com pedaços de texto (conhecidos como "strings" em programação).
    - Executar o código em resposta a determinados eventos que ocorrem em uma página da Web.
    - E muito mais!
    
    ---
    # Javascript   

    O que é ainda mais empolgante é a funcionalidade construída no topo do núcleo da linguagem JavaScript. As APIs (Application Programming Interfaces - Interface de Programação de Aplicativos) provêem a você superpoderes extras para usar no seu código JavaScript. Elas geralmente se dividem em duas categorias.

    <br/><img src="https://mdn.mozillademos.org/files/14721/browser.png " title="Javascript Pro" alt="Javascript Pro logo" style="max-height: 400px;clear: both; float: none;margin: 0px auto;" />
    
    ---
    # Javascript   

    - APIs de navegadores já vem implementadas no navegador, e são capazes de expor dados do ambiente do computador, ou fazer coisas complexas e úteis. Por exemplo:
    - A  API DOM (Document Object Model) permite a você manipular HTML e CSS, criando, removendo e mudando HTML, aplicando dinamicamente novos estilos para a sua página, etc. Toda vez que você vê uma janela popup aparecer em uma página, ou vê algum novo conteúdo sendo exibido (como nós vimos acima na nossa simples demonstração), isso é o DOM em ação.
    - A API de Geolocalização recupera informações geográficas. É assim que o Google Maps consegue entontrar sua localização e colocar em um mapa.
    - As APIs Canvas e WebGL permite a você criar gráficos 2D e 3D animados. Há pessoas fazendo algumas coisas fantásticas usando essas tecnologias web — veja Chrome Experiments e webglsamples.
    - APIs de áudio e vídeo como HTMLMediaElement e WebRTC permitem a você fazer coisas realmente interessantes com multimídia, tanto tocar música e vídeo em uma página da web, como capturar vídeos com a sua câmera e exibir no computador de outra pessoa (veja Snapshot demo para ter uma ideia).
  
    ---
    # Javascript
    
    O Javascript é uma linguagem script dinâmica, fracamente tipada, baseada em protótipos e que possui funções de primeira classe.


    Linguagem dinâmica: Linguagem de alto nível que executa em tempo de execução várias tarefas que outras linguagens executariam durante a compilação.

     
    Fracamente tipada:  Suporta conversão de tipos implícita, e não se declara o tipo na inicialização da variável.

    Baseada em protótipos: Estilo de orientação a objetos onde classes não existem, dessa forma o reuso (herança para linguagens baseadas em classe) é feito clonando objetos existentes que servem assim de protótipos.

    ---
    name: erros
    class: middle, center
    # Tratamento de erros em Javascript

    O processo de encontrar erros(bugs) nos programas é chamado de depuração.
  
    ---
    # Tratamento de erros em Javascript
  
    JavaScript pode ser feito de uma forma mais rigorosa, permitindo que o modo seja estrito. Para obter esse modo basta inserir uma string “use strict” na parte superior de um arquivo ou no corpo de uma função. Veja um exemplo:

    ```javascript

    function canYouSpotTheProblem() {
        "use strict";
        for (counter = 0; counter < 10; counter++)
            console.log("Happy happy");
    }
    ​
    canYouSpotTheProblem(); // ReferenceError: counter is not defined

    ```

    Normalmente, quando você esquece de colocar var na frente de sua variável como acontece no contador do exemplo, o JavaScript cria uma variável global para utiliza-la, no entando no modo estrito um erro é relatado. Isto é muito útil. Porém deve-se notar que isso não funciona quando a variável em questão já existe como uma variável global, isso é apenas para atribuição ou criação.
    
    ---
    # Tratamento de erros em Javascript    

    Por exemplo, considere o seguinte código que chama um construtor sem a nova palavra-chave na qual seu objeto não vai se referir a um objeto recém-construído:
    
    ```javascript
    function Person(name) { this.name = name; }
    var ferdinand = Person("Ferdinand"); // oops
    console.log(name); // Ferdinand

    ```
    
    Assim, a falsa chamada para Person foi bem sucessida, mas retornou um valor indefinido e criou uma variável global. No modo estrito, o resultado é diferente.
   
    ```javascript
    "use strict";
    function Person(name) { this.name = name; } // Oops, forgot 'new'
    var ferdinand = Person("Ferdinand");
    // TypeError: Cannot set property 'name' of undefined

    ```

    Somos imediatamente informados de que algo está errado. Isso é útil.


    ---
    # Tratamento de erros em Javascript

    Com o objetivo de tratar exceções e controlar erros, em tempo de execução, algumas linguagens implementam alguns mecanismos interessantes, como por exemplo Go, que você pode trabalhar com funções de retornos múltiplos para passar erro e dados em caso de sucesso; e Bash que se trata erros quando o exit do programa é maior que zero 0, já que zero significa sucesso, sem falar no “exception” de comandos encadeados com & &. 
  
    ---
    # Tratamento de erros em Javascript

    As exceções são utilizadas como uma forma de feedback, para cógido saber o que fazer quando cair numa situação de erro. 

    Agora você precisa entender que os statements (declarações, ou “comandos”) e os objetos citados aqui são coisas separadas, apesar de funcionar em conjunto. Mais precisamente, vamos falar sobre 3 coisas:

    - Objetos do tipo Error

    - o throw

    - o bloco try...catch
  
    ---
    # Tratamento de erros em Javascript

    ## Objetos do tipo  _Error_

    Sabe quando o console te mostra algum erro de sintaxe, ou um erro de referência, falando que uma variável ou função não existe? Aquelas mensagens esquisitas são dos objetos de  `Error`. Basicamente, esses objetos tem seu prototype composto pelos seguintes itens:

    -   `.constructor`: que inicializa os objetos, é chamado quando se instancia com o  `new`, ou apenas chamando como função  `Error()`;
        
    -   `.message`: a mensagem de erro, que é passada como primeiro argumento do construtor;
        
    -   `.name`: o tipo do erro. Ex.: “_Error_”, “_ReferenceError_”;
        
    -   `.toString()`: herdado do  `Object.prototype.toString()`  e retorna o valor de  `.message`.
  
    ---
    # Tratamento de erros em Javascript

    A propriedade  `.name`  especifica o tipo do Erro. Vamos dar uma olhada nos erros  **nativos**  e quando aparecem:

    -   **_EvalError_**: lançado quando a função  `eval()`  lança algum erro;
        
    -   **_RangeError_**: lançado quando encontra algum valor não está dentro do intervalo permitido;
        
    -   **_ReferenceError_**: lançado quando uma referência inválida é detectada;
        
    -   **_SyntaxError_**: lançado quando existe algum erro no  _parse_, no momento que a  _engine_  lê o código para interpretá-lo;
        
    -   **_TypeError_**: lançado quando um parâmetro de uma função não é do tipo desejado;
        
    -   **_URIError_**: lançado quando alguma operação de URI,  `encodeURI()`  ou  `decodeURI()`, recebem parâmetros inválidos.
  
    ---
    # Tratamento de erros em Javascript

    Bom, este são os erros nativos. Já que são extensões do objeto  `Error`, nós também podemos criar nossos erros, para poder tratá-los da melhor forma possível. Exemplo:

    ```javscript
    // Erro para regras de negócio
    class BusinessError extends Error {
      constructor(msg) {
        super(msg);
      }

      // e podemos adicionar algum método específico
    }

    ```
  
    ---
    # Tratamento de erros em Javascript
    ## O “lançamento”:  _throw_

    Reparou que falei dos erros serem lançados? É exatamente isso que acontece.

    Durante a execução do programa, se houver algum tipo de inconsistência, dos tipos nativos de erro, ou se houver alguma situação que devemos avisar sobre erros, utiliza-se o  `throw`  para lançar “coisas” para que “alguém” faça algo com essa coisa.
  
    ---
    # Tratamento de erros em Javascript

    Eu disse lançar “coisas” porque você pode lançar qualquer coisa, dentre elas, objetos de erro. Por exemplo:

    ```javascript
    // lançar um erro de negócio, com nossa classe `BusinessError`
    throw new BusinessError('CPF inválido');

    // lançar uma string de erro
    throw "Erro: foo";

    // lançar o status de erro HTTP
    throw 404;

    // lançar objetos literais
    throw {
      message: "Erro: bar",
      toString: function() {
        return this.message;
      }
    };

    // lançar funções
    throw function() { /* ¯\_(ツ)_/¯ */ }

    ```
  
    ---
    # Tratamento de erros em Javascript
    
    ## O bloco  _try..catch_

    Enquanto se  _tenta_  executar determinado trecho de código, pode ser que tenhamos erros que quebram o fluxo e todo o programa, não é mesmo? Para resolver esse problema, podemos tratar alguns erros no caso de  **_falha_**  durante a  **_tentativa_**. Por isso, utilizamos o  `try..catch`.

    A responsabilidade desta estrutura é  **tentar executar algo**  e, caso dê algum problema durante a execução,  **pegar os erros**  e tratá-los da forma mais adequada possível.

    Então:

    > O  `catch`  é quem pega as coisas lançadas pelo  `throw`  dentro do bloco  `try`

    ---
    # Tratamento de erros em Javascript
    
    Para entender melhor:

    ```javascript

    // "Tentamos" executar algo
    try {

      /* ... */

      // Caso haja algum erro que precise de tratamento (ex.: de negócio)
      if ( !usuario.permissao ) {

        // "Lançamos" um objeto de erro para o `catch`
        throw new BusinessError("Acesso não autorizado");

      }

      /* ... */

    // O `catch` "pega" qualquer coisa lançada no `try`, através do `throw`
    } catch (err) {

      // e fazemos o que precisar com isso
      alert(err.message);

    }


    ```

    Lembre o seguinte: qualquer erro nativo também é lançado e cairá no  `catch`.
  
    ---
    # Tratamento de erros em Javascript

    ## _finally_

    O bloco  `try..catch`  também permite a execução de coisas no fim da execução do bloco, tendo sucesso ou caindo no  `catch`. Para isso, utilizamos o bloco  `finally`. Exemplo:

    ```javascript
    try {
       /* ... */
        // "Lançamos" um objeto de erro para o `catch`
        throw new BusinessError("Acesso não autorizado");

    } catch (e) {
       // e fazemos o que precisar com isso
      alert(err.message);

    } finally {
      // Sempre executa ao finalizar o `try` ou o `catch`
      // É um bom lugar pra executar coisas como:
      //  * fechar uma transação com o DB;
      //  * fechar arquivos que foram abertos para leitura;
      //  * atualizar o estado da view;

    }


    ```
  
    ---
    # Tratamento de erros em Javascript


    ## Lançando Seus Próprios Erros

    Lançar seus próprios erros é uma excelente prática para você distinguir suas próprias exceções da do browser e dar contexto ao desenvolvedor para que ele possa mais facilmente resolver o problema.
    
    ```javascript
    function MyError(message, solution, location) {  
        this.message = message + " Solution:" + solution +  " Location:" + location;
        this.solution = solution;
        this.location = location;
    }

    MyError.prototype = new Error();  
    MyError.prototype.name = "My Error"; 
    ``` 
    ---
    # Tratamento de erros em Javascript

    ### Observação

    Este mecanismo de tratamento de erros em tempo de execução (com  `try..catch..finally`  e  `throw`) também é adotado por outras linguagens. Podemos citar PHP e Java como exemplo e cada uma delas tem seus objetos de erro específicos. JavaScript utiliza os objetos do tipo  `Error`, PHP e Java tem seus objetos de  `Exception`, que servem pra mesma coisa.

    ---
    # Tratamento de erros em Javascript
  
    ## Referências

    -   Error Objects -  [http://www.ecma-international.org/ecma-262/7.0/index.html#sec-error-objects](http://www.ecma-international.org/ecma-262/7.0/index.html#sec-error-objects)
    -   ECMAScript Language: Statements and Declarations -  [http://www.ecma-international.org/ecma-262/7.0/index.html#sec-ecmascript-language-statements-and-declarations](http://www.ecma-international.org/ecma-262/7.0/index.html#sec-ecmascript-language-statements-and-declarations)
    -   Error -  [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
    -   throw -  [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw)
    -   try…catch -  [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try…catch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch)
    -   try…catch…finally Statement (JavaScript) -  [https://docs.microsoft.com/en-us/scripting/javascript/reference/try-dot-dot-dot-catch-dot-dot-dot-finally-statement-javascript](https://docs.microsoft.com/en-us/scripting/javascript/reference/try-dot-dot-dot-catch-dot-dot-dot-finally-statement-javascript)
    -   throw Statement (JavaScript) -  [https://docs.microsoft.com/en-us/scripting/javascript/reference/throw-statement-javascript](https://docs.microsoft.com/en-us/scripting/javascript/reference/throw-statement-javascript)
    -   Error Object (JavaScript) -  [https://docs.microsoft.com/en-us/scripting/javascript/reference/error-object-javascript](https://docs.microsoft.com/en-us/scripting/javascript/reference/error-object-javascript)
    


    ---
    class: center, middle
    # Escopo e Hoisting



    ---
    # Escopo e Hoisting

    _Variable hoisting_  é o procedimento do JavaScript que move declarações para o topo de seus escopos atuais. Por não ser explícito, desconhecer como isso funciona pode trazer boas dores de cabeça.

    Qual você acha que será a saída no Console do seguinte script?

    ```javascript
    var number = 10;
    function init(){
        console.log(number);
        var number = 5;
    }
    init();

    ```   

    Existe uma grande chance de que você achou que a saída seria  `10`. Por causa da forma como o JavaScript trata declarações e escopos, a saída deste script é  `undefined`  (!). Isso mesmo, pode conferir no Console do seu navegador. Para entender como e porque isso acontece, é muito importante primeiro compreender o escopo no JavaScript.      
    
    ---
    
    # Escopo e Hoisting 

    ## Um pouco sobre escopo no JavaScript

    Escopo em uma linguagem de programação é basicamente a seção em que suas declarações estarão visíveis. No JavaScript, temos o escopo global, que pode ser acessado por qualquer script da página, e o local, que está visível apenas para quem está do lado de dentro. Funções são a principal forma de criar escopos locais no JavaScript. Para simplificar este artigo tratarei das outras maneiras de criar escopos locais apenas ao final.

    Tudo isso significa que as variáveis que são declaradas dentro de um escopo local só podem ser acessadas por quem estiver do lado de dentro.


    ---
    
    # Escopo e Hoisting  
    ## Um pouco sobre escopo no JavaScript

    Uma variável  `count` declarada dentro da função  `countHumans`  não estará visível na função  `countAnimals`  no exemplo a seguir:

    ```javascript
    var humans = ['Hugo', 'Jéssica', 'Victor'];
    var animals = ['dog', 'cat'];

    function countHumans() {
        var count = humans.length;
        return count;
    } // => 3

    function countAnimals() {
        var count = animals.length;
        return count;
    } // => 2

    ```

    Graças a essa funcionalidade, podemos utilizar bons nomes nas nossas variáveis sem nos preocuparmos demais com conflitos entre elas.

    Escopos que estão dentro de outros podem acessar todas as variáveis ali declaradas, tanto para ler quanto para mudar seus valores.       
    
    ---
    # Escopo e Hoisting  

    ## O que é Escopo?
    Em ES5, as funções são nosso delimitador de escopo de fato para declaração de variáveis. Isso significa que blocos usuais de loops e estruturas condicionais (como if,for, while, switch e try) NÃO delimitam escopos, diferente de muitas outras linguagens como C, C++, Java e ES2015.
    Portanto, esses blocos compartilham do mesmo escopo que a função que os contém. Dessa forma, pode ser perigoso declarar variáveis dentro de blocos, já que vai parecer que a variável pertence apenas ao bloco. Esse é um problema comum para programadores vindos de linguagens com escopos em blocos.       

    ---
    # Escopo e Hoisting  

    ## Como entrar em um escopo?

    Temos quatro maneiras:

    -   Definido pela linguagem: todo escopo possui o this e, caso seja uma função, também o arguments;
    -   Declaração de uma variável: variáveis declaradas como var name;
    -   Declaração de uma função: funções declaradas na forma function family() {};
    -   Parâmetros de uma função: caso uma função seja chamada na forma brother (name), podendo ser brother (name, mother, …), sendo name e mother entram no escopo da função.       
        
    ---
    # Escopo e Hoisting  

    Como poderia ficar nosso código:

    ```javascript
    var val = 1;
    scopeBloc();

    function scopeBloc() {    
    for(var i = 0; i < 10; i++) {
        var newVal = val + i;
        console.log(newVal); // 10
     }     
     console.log(newVal); // 10
     console.log(val); // 1 
    }

    ```

    No código acima ainda podemos acessar a varivel newVal fora do bloco do loop, bem como podemos criar um escopo dentro do loop em ES5 utilizando ‘IIFE’. 

    
    ---
    # Escopo e Hoisting   

    Essa era nossa única maneira de se criar um escopo dentro de um bloco, mas com a vinda do ES2015 isto mudou.  
    
    ```javascript
    var val = 1;
    scopeBloc();
     
    function scopeBloc() {    
        for(var i = 0; i < 10; i++) {
            (function() {
                var newVal = val + i;
                console.log(newVal); // 10
            }());
        }     
        console.log(newVal); // ReferenceError: newVal is not defined
        console.log(val); // 1 
    }

    ```    
    ---
    # Escopo e Hoisting 

    Vamos ver se ficou claro:

    ```javascript
    var val = 1; // escopo global
    var text = "Estudando Escopo"; // escopo global
    function scopeBloc() {    
        for(var i = 0; i < 10; i++) { // i escopo local
            (function() {
                var newVal = val + i; // newVal escopo do bloco if
                console.log(newVal); // vai fazer o loop de 1 a 10
                console.log(text); 
                // var fazer o loop com a string Estudando Escopo
            }());
         }
         var getPhrase =  function() {
             var val = 2; // ecopo de bloco
             Pharse = "I love JavaScript"; 
             // escopo global (var não foi utilizada)
            console.log(val); // 2
            console.log(i); // 10
            console.log(text); // Estudando Escopo
            console.log(Pharse); // I love JavaScript
         }();
         console.log(newVal); // ReferenceError: newVal is not defined
         console.log(val); // 1 
    }     
    scopeBloc();
    console.log(val); // 1
    console.log(text); // Estudando Escopo
    console.log(Pharse); // I love JavaScript
    ```

    ---
    # Escopo e Hoisting   

    E o que é this?

    This é uma referência ao contexto no qual a função está sendo executada, ao objeto ao qual ela pertence. Em grande parte de outras linguagens othis é uma referência ao objeto atual instanciado. Contudo, para dar um nó na sua mente, em JavaScript o this vai depender de como sua função foi inicializada.

    Algumas formas de chamar uma função:

    1.  Diretamente
    2.  Como um método
    3.  Explicitamente aplicada
    4.  Como construtor
      
    ---
    # Escopo e Hoisting   

    ## Diretamente

    ```javascript
    var text = 'Escopo em Javascript'
    function createPhrase(textA, textB) {
        var textC = 'Quando uma função é chamada diretamente'
        console.log(this); // imprimi window
        console.log(textA + textB + ' - ' + textC); 
        // Entendendo como funciona Escopo em Javascript 
        // Quando uma função é chamada diretamente 
    }
     
    createPhrase('Entendendo como funciona ', text);

    ```

    Quando uma função é chamada diretamente, this fará referência ao contexto global, que no caso dos navegadores é o objeto window.


    ---
    # Escopo e Hoisting   

    ## Como um método

    São funções armazenadas dentro das propriedades de um objeto. Se uma função for chamada como um método de um objeto, então this, dentro dessa função, fará referência a esse objeto.
    
    ```javascript
    var text = 'Escopo em Javascript'
    var myObject = {
        textA: 'Entendendo como funciona ',
        textB: 'Quando uma função é chamada com um método',
        createPhrase: function (textC) {
            console.log(this.textA + textC + ' - ' + this.textB); 
            // Entendendo como funciona Escopo em Javascript
            // Quando uma função é chamada com um método
        }
    };
     
    myObject.createPhrase(text);
    ```
    ---
    # Escopo e Hoisting   

    ## Explicitamente aplicada

    Uma função pode ser aplicada explicitamente a qualquer objeto, e para isso utilizamos os métodos call ou apply.

    Os métodos call e apply nos permitem controlar o valor de this e assim definir a qual objeto ele fará referência. A diferença entre eles é a forma que recebem os parâmetros e também a velocidade de execução que pode variar de navegador para navegador.

    ```javascript
        var text = 'Escopo em Javascript';
        var myObject = {
            phraseC: 'Entendendo como funciona ',
            phraseD: 'Quando uma função é aplicada explicitamente'
        };
         
        function createPhrase(phraseA, phraseB) {
            console.log(this); // imprimi objeto
            console.log(this.phraseC + phraseA  + ' - ' +  this.phraseD  + ' => ' + phraseB); 
            // Entendendo como funciona Escopo em Javascript 
            // Quando uma função é aplicada explicitamente => entenderam ?
        }
         
        createPhrase.call(myObject, text, 'entenderam ?');  
        createPhrase.apply(myObject, [text, 'entenderam ?']);

    ```

    ---
    # Escopo e Hoisting   

     ## Explicitamente aplicada

    Na função createPhrase faço referência ao objeto ‘myObject’. Com isso, consigo acessar os nós dele: this.phraseC que tem como valor Entendendo como funciona e this.phraseD que tem como valor Quando uma função é aplicada explicitamente.

    ---
    # Escopo e Hoisting   

    ## Como um construtor

    Quando uma função é usada como um construtor (usando a palavra-chave new), this fará referência ao novo objeto que está sendo construído:

    ```javascript
    function work() {
        this.startWork = '8:00';
        this.finishWork = '19:00';
        this.officialName = officialName();
     
        this.getstartWork = function() {
            return this.startWork;
        };
     
        this.getfinishWork = function() {
            return this.finishWork;
        };
     
        this.getOfficialName = function() {
         return this.officialName;
        };
    };
     

    ```
    
    ---
    # Escopo e Hoisting   

    ## Como um construtor

    Quando uma função é usada como um construtor (usando a palavra-chave new), this fará referência ao novo objeto que está sendo construído:

    ```javascript
    function officialName() {
        var name = 'Luiz Celso F Alves';
        return name;
    };
     
    var myWork1 = new work();
    var myWork2 = new work();
     
    console.log('Entrada: '+myWork1.getstartWork());// Entrada: 8:00
    console.log('Saída: '+myWork1.getfinishWork()); // Saída: 19:00
    console.log('Nome: '+myWork1.getOfficialName());// Nome: Luiz Celso F Alves
     
    myWork2.startWork = '10:00';
    console.log('Novo horario de entrada: '+myWork2.startWork);// Novo horario de entrada: 10:00

    ```

    ---
    # Escopo e Hoisting 

    ## Como funcionam as declarações

    Declarar variáveis é algo extremamente necessário. Sem isso nossos códigos seriam simplesmente complicados demais. No JavaScript, declaramos uma variável usando o termo  `var`  seguido do nome que ela levará. Ela será adicionada ao escopo atual.

    O termo  `function`  também simboliza uma declaração de uma variável.  `function add(){}`  cria a variável  `add`  no escopo atual. Funções anônimas também podem ser declaradas ao omitirmos o nome (`function(){}`).

    Porém, ao contrário do que você talvez imagine, todas as declarações são feitas quando seu código JavaScript começa a ser compilado. Só depois do que chamamos de  _Compile Time_, o script começa a ser executado (na fase que chamamos de  _Runtime_).

       
    ---
    # Escopo e Hoisting 

    ## Como funcionam as declarações 

    O processo ocorre mais ou menos assim:

    1.  Durante o  _Compile Time_, todo o código é analisado. Declarações são encontradas e todas as variáveis são criadas dentro de seus respectivos escopos.
    2.  Após cada linha ser analisada, entramos em  _Runtime_. Seu código é, então, executado.

    Sendo assim, mesmo que sua declaração esteja no meio do código, ela será “içada” (_hoisted_, em inglês) para o início do escopo em que ela está inserida. Neste momento, todas as variáveis declaradas com o termo  `var`  ganham o valor de  `undefined`  e as funções têm seu conteúdo compilado. É isso que chamamos de  _hoisting_. Apenas quando entramos em  _Runtime_  todas as linhas são executadas, incluindo as atribuições.      


    ---
    # Escopo e Hoisting  

    Um pouco de código para entendermos melhor:

    1.  A linha  `var name = 'hugo';`  é interpretada durante o  _Compile Time_.
    2.  A variável  `name`  é criada no escopo em que está inserida.
    3.  Supondo que não temos mais linhas no código, terminamos o  _Compile Time_.
    4.  Em seguida voltamos à esta linha, que é executada durante o  _Runtime_.
    5.  Uma referência a  `name`  é procurada dentro do escopo atual.
    6.  Quando a referência é encontrada, o valor  `'hugo'`  é atribuído a ela.      
    ---
    # Escopo e Hoisting 

    ## Entendendo melhor o primeiro exemplo

    No primeiro exemplo, vimos que a saída no Console foi  `undefined`, mesmo tendo uma variável  `number`  já declarada antes da função ser executada.

    ```javascript
    var number = 10;
    function init(){
        console.log(number);
        var number = 5;
    }
    init();

    ```
       
    ---
    # Escopo e Hoisting   

    Isso aconteceu porque este script foi interpretado da seguinte forma:

    #### _Compile Time_

    1.  Começamos o  _Compile Time_  declarando a variável  `number`  da primeira linha no escopo global.
    2.  Logo depois declaramos a função  `init`  e iniciamos a sua compilação.
    3.  Dentro do escopo de  `init`  encontramos a declaração de  `number`  e adicionamos uma referência a ela dentro deste escopo.
    4.  Nenhuma outra declaração é encontrada e não temos nenhum erro de sintaxe. O  _Compile Time_  é finalizado.

    Neste momento o código está virtualmente assim:

    ```javascript
    // var number; (declarada no escopo global)
    function init(){
        // var number; (declarada no escopo de init)
        console.log(number);
        number = 5;
    }

    number = 10;
    init();

    ```

    ---
    # Escopo e Hoisting  

    #### _Runtime_

    1.  Entramos no modo de execução. Pulando as declarações, começamos com  `number = 10`.
    2.  A variável  `number`  do escopo global é a que recebe o valor de  `10`
    3.  Em seguida, a linha  `init()`  executa a função  `init`.
    4.  Dentro de  `init`  rodamos o  `console.log(number)`.  `number`  se refere à  `number`  do escopo de  `init`. Por enquanto o valor deste  `number`  é  `undefined`.
    5.  Na última linha da função  `init`, executamos  `number = 5`. A variável  `number`de dentro do escopo de  `init`  agora tem o valor de  `5`.

    Esse comportamento de “içar” variáveis parece anormal, já que esperamos que a declaração e atribuição da variável aconteçam no mesmo momento e na linha em que ela se encontra. Porém, por causa da forma como o JavaScript é compilado e interpretado, estas duas ações acontecem em momentos diferentes.

    ---
    # Escopo e Hoisting  

    Ter a fase de compilação do JavaScript é essencial para que o script seja validado corretamente pelo navegador ou outra plataforma que executará seu código. Além disso, quem executa o JavaScript pode preparar de antemão cache para escopos, variáveis e funções.

    Entender pelo menos o básico de escopo e  _variable hoisting_  é essencial para escrevermos JavaScript de qualidade.      
    ---
    # Escopo e Hoisting  

    ## Evitando problemas

    Para evitar que você tenha problemas por causa do  _hoisting_, a melhor dica que posso te dar é: declare as variáveis no início do escopo, mesmo sem a inicialização.

    ```javascript
    function countUsers() {
        var count, users;
        users = app.users;
        count = users.length;

        return count;
    }

    ```

    Para te ajudar a encontrar lugares onde o  _hoisting_  pode trazer problemas, é interessante usar um  _linter_  ou  _hinter_  no seu código. Essas ferramentas analisam o que você escreveu e te dão dicas para melhorar. Um dos mais conhecidos é o  [JSHint](http://www.jshint.com/).

    ---
    # Escopo e Hoisting

    ## Outras formas de criar escopos

    Além de funções, existem também outras formas de se criar um novo escopo no JavaScript:

    -   Usando a função  `eval()`. Mas evite, pois  [Eval is Evil](http://stackoverflow.com/questions/86513/why-is-using-the-javascript-eval-function-a-bad-idea).
    -   Dentro de  `catch`  em um  `try`.  [Saiba mais sobre  `try…catch`](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Statements/try...catch).
    -   Dentro de um  `with`.  [Saiba mais sobre  `with`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with). Evite este cara também.

    Escopos não são criados dentro de todos os blocos, logo, variáveis declaradas dentro de  `if`,  `for`,  `switch`  ou outro bloco são criadas dentro do escopo em que estes blocos estão.

    Porém, a partir do EcmaScript 6 (nova versão da especificação para implementação do JavaScript), o termo  `let`  nos deixará declarar variáveis que são criadas em escopos dentro destes blocos. Isso vai ser bem interessante, já que permitirá a criação de variáveis dentro de loops  `for`, por exemplo.  [Veja um pouco mais sobre como usar o  `let`](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Statements/let).          

    ---
    class: center, middle
    # jQuery

    ---
    # Introdução ao jQuery 

    Por conta das dificuldades enfrentadas pelos programadores JavaScript para páginas Web, foi criada uma biblioteca que traz diversas funcionalidades voltadas à solução dos problemas mais difíceis de serem contornados com o uso do JavaScript puro.

    A principal vantagem na adoção de uma biblioteca de JavaScript é permitir uma maior compatibilidade de um mesmo código com diversos navegadores. Uma maneira de se atingir esse objetivo é criando funções que verificam quaisquer características necessárias e permitam que o programador escreva um código único para todos os navegadores.

    Além dessa vantagem, o jQuery, que é hoje a biblioteca padrão na programação front-end para Web, traz uma sintaxe mais "fluida" nas tarefas mais comuns ao programador que são: selecionar um elemento do documento e alterar suas características.

    ---
    # Introdução ao jQuery

    ## Principais funcionalidades do jQuery

    - Resolução da incompatibilidade entre os navegadores.
    - Redução de código.
    - Reutilização do código através de plugins.
    - Utilização de uma vasta quantidade de plugins criados por outros desenvolvedores.
    - Trabalha com AJAX e DOM.
    - Implementação segura de recursos do CSS1, CSS2 e CSS3.
    
    ---
    # Introdução ao jQuery

    ## O que é jQuery?
    jQuery é uma ***biblioteca***, ou um conjunto de incrementos úteis, para a linguagem de programação JavaScript. Pode parecer contra intuitivo aprender a usar uma biblioteca antes de aprender a linguagem de fato, mas há algumas boas razões para isso.

    Demora um pouco até que se fique familiarizado e confortável com JavaScript, e é mais difícil manipular elementos HTML diretamente por JavaScript do que por jQuery. Para ajudá-lo a construir websites fantásticos mais rápido, vamos começar com jQuery.
    jQuery oferece uma interface simples para o básico de JavaScript. Para muitos usuários é mais fácil aprender jQuery primeiro e então mergulhar nos detalhes profundos de JavaScript mais tarde.
    jQuery é muito melhor no que diz respeito a dar resultados visuais imediatos do que JavaScript. No final desta lição, você terá construído seu próprio botão interativo!
    

    ---
    # Introdução ao jQuery

    ## Modelo de Objetos de Documentos

    Um documento HTML é estruturado de acordo com o Modelo de Objetos de Documentos, ou DOM (do inglês Document Object Model). É por meio da interação com o DOM que a jQuery é capaz de acessar e modificar códigos HTML.

    O DOM é composto por todos os elementos da página, organizados de forma hierárquica, refletindo a maneira como o documento HTML é ordenado
    
    ---
    # Introdução ao jQuery

    Assim como o div de CSS se refere ao elemento HTML < div >, o 'div' da jQuery se refere ao mesmo elemento HTML < div >. 

    Você pode pensar no nome do elemento passado para a jQuery como sendo idêntico ao elemento CSS, ele apenas fica entre aspas. 
    
    ---
    # Introdução ao jQuery

    Então, por exemplo, você pode apontar qualquer coisa da classe 'button' com

    ```javascript
    $('.button').someAction
    ```

    Como você deve lembrar, .button no seu arquivo CSS é como você aponta qualquer coisa de class="button" no seu arquivo HTML.
    
    ---
    # Introdução ao jQuery  

    ## jQuery Selectors
    
    Um dos maiores poderes do jQuery está na sua capacidade de selecionar elementos a partir de seletores CSS.

    Como já aprendemos, exitem diversas formas de selecionarmos quais elementos ganharão determinado estilo. Infelizmente muitos desses seletores não funcionam em todos os navegadores. Contudo, no jQuery, os temos todos à nossa disposição.

    Por exemplo, se quisermos esconder todas as tags < td > filhas de um < tbody >, basta:

    ```javascript
    $('tbody td').hide();
    ```

    ---
    # Introdução ao jQuery

    Seletores mais comuns:

    ```javascript
    // pinta o fundo do formulario com id "form" de preto
    $('#form').css('background', 'black');

    // esconde todos os elementos com o atributo "class" igual a "headline"
    $('.headline').hide();
    

    // muda o texto de todos os parágrafos
    $('p').text('alô :D');
    ```

    Mais exemplos:

    ```javascript
    $('div > p:first'); // o primeiro elemento <p> imediatamente filho de um <div>

    $('input:hidden'); // todos os inputs invisíveis

    $('input:selected'); // todas as checkboxes selecionadas

    $('input[type=button]'); // todos os inputs com type="button"

    $('td, th'); // todas as tds e ths
    ```

    ---
    # Introdução ao jQuery

    Lembre-se de que a função que chamamos após o seletor é aplicada para todos os elementos retornados. Veja:

    ```javascript
    // forma ineficiente
    alert($('div').text() + $('p').text() + $('ul li').text());

    // forma eficiente :D
    alert($('div, p, ul li').text());

    ```
    A função text() é chamada para todos os < div >s, < p >s, e < li >s filhos de < ul >s.

    ---
    # Introdução ao jQuery

    ##  Filtros customizados e por DOM

    Existem diversos seletores herdados do css que servem para selecionar elementos baseados no DOM. Alguns deles são:

    ```javascript
        $('div > p'); // <p>s imediatamente filhos de <div>
        $('p + p'); // <p>s imediatamente precedidos por outro <p>
        $('div:first-child'); // um elemento <div> que seja o primeiro filho
        $('div:last-child'); // um elemento <div> que seja o último filho
        $('div > *:first-child'); // um elemento que seja o primeiro filho direto de uma <div>
        $('div > *:last-child'); // um elemento que seja o ultimo filho direto de uma <div>
        $('div p:nth(0)'); // o primeiro elemento <p> filho de uma <div>
        $('div:empty'); // <div>s vazios
    ```


    ---
    # Introdução ao jQuery
    ## Começando

    A seguir, precisamos dar início à mágica da jQuery usando a sintaxe $(document).ready(); que você viu. Ela funciona assim:

    ```javascript
    $(document).ready(function(){

    });
    ```

    - $() diz, "ei, a mágica da jQuery está prestes a acontecer!"
    - Colocar o documento document entre parênteses nos diz que estamos prestes a realizar nossa mágica no próprio documento HTML.
    - .ready(); é uma função, ou ação básica, em jQuery. Ela diz "ei, vou começar a fazer as coisas assim que o documento HTML estiver pronto!"
    - Qualquer coisa dentro dos parênteses de .ready() é o evento jQuery que acontece assim que o documento HTML fica pronto.
    
    ---
    # Introdução ao jQuery

    Assim,

    ```javascript
    $(document).ready(something);

    ```
    diz: "quando o documento HTML estiver pronto, faça something!" (Vamos te mostrar como substituir o something por uma ação no próximo exercício.)

    Perceba que .ready(); termina com um ponto-e-vírgula. Isso mostra para a jQuery que você terminou o comando.

    
    ---
    # Introdução ao jQuery

    ## Utilitário de iteração do jQuery

    O jQuery traz também entre suas diversas funcionalidades, uma função que facilita a iteração em elementos de um Array com uma sintaxe mais agradável:

    ```javascript
    $("#menu-departamentos li").each(function (index, item) {
        alert(item.text());
    });
    ```
    
    ---
    # Introdução ao jQuery

    A função each chamada logo após um seletor executa a função que passamos como argumento para cada um dos itens encontrados. Essa função precisa de dois argumentos. O primeiro será o "índice" do elemento atual na coleção (0 para o primeiro, 1 para o segundo e assim por diante), e o segundo será o próprio elemento.

    Também é possível utilizar a função each do jQuery com qualquer Array:
    
    ```javascript

    var pessoas = ["João", "José", "Maria", "Antônio"];

    $.each(pessoas, function(index, item) {
        alert(item);
    })

    ```
    Nesse caso, chamamos a função each diretamente após o $, pois essa implementação é um método do próprio objeto $. Passamos dois argumentos, o primeiro é o Array que queremos percorrer e o segundo a função que desejamos executar para cada um dos itens do Array.
    

    ---
    # Introdução ao jQuery


    ```javascript
    $('.novidades button').click(function() {
        $('.novidades').removeClass('painel-compacto');
    });
    ```

    Mais exemplos:

    -   [Documentação da API do jQuery](http://jquery.com/api/)
    -   [jQuery Selectors](https://www.tutorialrepublic.com/jquery-reference/jquery-selectors.php)
    -   [Visual jQuery - Uma documentação categorizada e navegável da API do jQuery](http://visualjquery.com/)
    -   [Expressões do jQuery: CSS](http://jquery.com/docs/Base/Expression/CSS/)
    -   [Expressões do jQuery: XPath](http://jquery.com/docs/Base/Expression/XPath/)
    -   [Expressões do jQuery: Customizadas](http://jquery.com/docs/Base/Expression/Custom/)
    -   [Eventos especiais no jQuery](http://jquery.com/docs/EventModule/)
    -   [jQuery DOM Traversing](http://jquery.com/docs/Base/Traverse/)


    ---
    class: center, middle
    # AJAX        

    ---
    # AJAX   
    ## XMLHttpRequest aka AJAX

    [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest "XMLHttpRequest")  torna o envio de requisições HTTP muito fácil. Basta criar uma instância do objeto, abrir uma url e enviar uma requisição. O [status](https://developer.mozilla.org/en-US/docs/HTTP/HTTP_response_codes "HTTP response codes") [HTTP](https://developer.mozilla.org/en-US/docs/HTTP/HTTP_response_codes "HTTP response codes") do resultado assim como o seu conteúdo estarão disponíveis quando a transação for completada. Esta página descreve alguns casos comuns de uso desse poderoso objeto JavaScript.

    ```js
    function reqListener () {
      console.log(this.responseText);
    };

    var oReq = new XMLHttpRequest();
    oReq.onload = reqListener;
    oReq.open("get", "yourFile.txt", true);
    oReq.send();
    ``` 
    ---
    # AJAX   

    ## Tipos de Requisições

    Uma requisição feita via XMLHttpRequest pode buscar dados de duas maneiras, sícrona e assíncrona. O tipo de requisição é dado pelo argumento  `async`  que é opcional (terceiro argumento) e é definido no método XMLHttpRequest [open()](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#open() "DOM/XMLHttpRequest#open()"). Se esse argumento for  `true`ou não especificado, o  `XMLHttpRequest`  será processado de maneira assíncrona, caso contrário o processamento será síncrono. Uma discussão detalhada e demonstrações desses dois tipos podem ser encontradas na página [requisições síncronas e assíncronas](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Synchronous_and_Asynchronous_Requests "Synchronous and Asynchronous Requests"). No geral a melhor prática é a das solicitações assíncronas.
    ---
    # AJAX 

    ## Manipulando Respostas

    Existem vários tipos de  [atributos de resposta](http://www.w3.org/TR/XMLHttpRequest2/#response "http://www.w3.org/TR/XMLHttpRequest2/#response") definidos pela especificação da W3C para o XMLHttpRequest. Eles informam ao cliente que efetuou a requisição XMLHttpRequest informações importantes sobre o status da resposta. Em alguns casos onde se lida com tipos de resposa de não-texto, os tipos de resposta podem envolver alguma manipulação e/ou análise conforme descrito nas seções seguintes.

    ---
    # AJAX 

    ### Analisando e manipulando a propriedade  `responseXML`

    Se você utiliza o  `XMLHttpRequest` para obter o conteúdo de um documento XML remoto, a propriedade  `responseXML`  será um objeto DOM que contém um documento XML, o que pode dificultar a manipulação e análise.

    As cinco formas mais utilizadas para análisar e manipular um arquivo XML são:

    1.  Usando  [XPath](https://developer.mozilla.org/en-US/docs/XPath "XPath")  para análisar parte deles.
    2.  Usando  [JXON](https://developer.mozilla.org/en-US/docs/JXON "JXON")  para converter em um Objeto JavaScript.
    3.  Manualmente  [Parsing and serializing XML](https://developer.mozilla.org/en-US/docs/Parsing_and_serializing_XML "Parsing_and_serializing_XML")  para strings ou objetos.
    4.  Usando  [XMLSerializer](https://developer.mozilla.org/en-US/docs/XMLSerializer "XMLSerializer")  para serializar  **árvores do DOM para strings ou para arquivos**.
    5.  [RegExp](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp") pode ser usado se você souber de antemão qual é o conteúdo do XML. Você pode remover quebras de linhas, usando a RegExp para procurar as quebras de linha. No entanto, este é o "último método", caso o código do XML sofra alterações, o método se torna falho.     
    ---
    # AJAX

    ### Analisando e manipulando uma propriedade  `responseText`  contendo um documento HTML

    Se você usa o  `XMLHttpRequest`  para recuperar o conteúdo de uma página HTML remota, a propriedade  `responseText`  será uma string contendo um a "sopa" de todos as tags HTML, o que pode ser difícil de manipular e analizar. Existem três formas básicas para analizar esta sopa de string HTML:

    1.  Use a propriedade `XMLHttpRequest.responseXML`.
    2.  Introduza o conteúdo dentro do corpo de um  [document fragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment)  Através de  `fragment.body.innerHTML`  e percorra o fragmento do DOM.
    3.  [RegExp](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp "https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp") pode se usada se você sempre conhece o conteúdo HTML  `responseText` de que tem em mãos. Você pode quere remover quebras de linha, se você usar RegExp para varrer no que diz respeito a quebra de linhas. Contudo, este método é um "último recurso" uma vez que se o código HTML mudar um pouco, o método provavelmente irá falhar.

    ---
    # AJAX

    ```js
    function xhrSuccess() { 
        this.callback.apply(this, this.arguments); 
    }

    function xhrError() { 
        console.error(this.statusText); 
    }

    function loadFile(url, callback /*, opt_arg1, opt_arg2, ... */) {
        var xhr = new XMLHttpRequest();
        xhr.callback = callback;
        xhr.arguments = Array.prototype.slice.call(arguments, 2);
        xhr.onload = xhrSuccess;
        xhr.onerror = xhrError;
        xhr.open("GET", url, true); // `false` makes the request synchronous
        xhr.send(null);
    }
    ``` 

    Usando:

    ```js
    function showMessage(message) {
        console.log(message + this.responseText);
    }

    loadFile("message.txt", showMessage, "New message!\n\n");
    ```


    ---
    # AJAX 

    Devido à política de mesma origem, linguagens client-side, como o JavaScript só podem fazer chamadas para o mesmo domínio.
    Se fizer uma chamada AJAX para outro domínio, ou então para seu próprio domínio, mas com uma porta diferente, HTTPS ou para um subdomínio, a chamada Ajax vai falhar.

    JSONP ou "JSON with padding" é um complemento ao formato de dados JSON. Ele provê um método para enviar requisições de dados de um servidor para um domínio diferente, uma coisa proibida pelos navegadores típicos.

    ---
    # AJAX 
    ## Controle de Acesso HTTP (CORS)

    Compartilhamento de recursos de origens cruzadas é um mecanismo que usa cabeçalhos HTTP adicionais para garantir permissão de acesso a recursos de um servidor diferente do da origem da página (domínio) correntemente em uso. Um user agent realiza um requisição HTTP de origem cruzada quando executa uma requisição de um domínio, protocolo ou porta diferente do qual originou o documento corrente.

    Um exemplo de requisição de origem cruzada: Uma pagina HTML acessada através de http://domain-a.com faz requisição de uma imagem [<img> src](https://developer.mozilla.org/pt-BR/docs/Web/HTML/Element/img#Atributos) para http://domain-b.com/image.jpg. Muita páginas na web, hoje em dia, utilizam recursos como CSS stylesheets, imagens e scripts de um domínio diferente do que originou a página corrente, como redes de entrega de conteúdo (CSN).

    ---
    # AJAX 
    ## Controle de Acesso HTTP (CORS)

    Por razões de segurança, os navegadores restringem solicitações HTTP de origem cruzada iniciadas a partir de scripts. Por exemplo, [`XMLHttpRequest`](https://developer.mozilla.org/pt-BR/docs/Web/API/XMLHttpRequest "XMLHttpRequest é uma API que fornece funcionalidade ao cliente para transferir dados entre um cliente e um servidor. Ele fornece uma maneira fácil de recuperar dados de um URL sem ter que fazer uma atualização de página inteira. Isso permite que uma página da Web atualize apenas uma parte do conteúdo sem interromper o que o usuário esteja fazendo. XMLHttpRequest é usado constantemente na programação de AJAX.")  e  [Fetch](https://developer.mozilla.org/pt-BR/docs/Web/API/Fetch_API)  seguem a  [política de mesma origem](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy). Assim, um aplicativo da web usando [`XMLHttpRequest`](https://developer.mozilla.org/pt-BR/docs/Web/API/XMLHttpRequest "XMLHttpRequest é uma API que fornece funcionalidade ao cliente para transferir dados entre um cliente e um servidor. Ele fornece uma maneira fácil de recuperar dados de um URL sem ter que fazer uma atualização de página inteira. Isso permite que uma página da Web atualize apenas uma parte do conteúdo sem interromper o que o usuário esteja fazendo. XMLHttpRequest é usado constantemente na programação de AJAX.")  ou  [Fetch](https://developer.mozilla.org/pt-BR/docs/Web/API/Fetch_API)  só poderá fazer solicitações HTTP para seu próprio domínio. Para melhorar os aplicativos da Web, os desenvolvedores solicitaram que os fornecedores de navegador permitissem solicitações entre domínios.

    <div style="width: 100%;background: #ffff; max-width: 100%;padding: 10px;text-align: center;">
        <img src="https://mdn.mozillademos.org/files/14295/CORS_principle.png" style="max-height: 265px;" />
    </div>

    ---
    # AJAX 

    O mecânismo de Compartilhamento de Recursos entre Origens ([CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)) fornece aos servidores de web controles de acesso entre domínios, que permitem transferências seguras de dados entre domínios. Os navegadores modernos usam o CORS em um container API - como [`XMLHttpRequest`](https://developer.mozilla.org/pt-BR/docs/Web/API/XMLHttpRequest "XMLHttpRequest é uma API que fornece funcionalidade ao cliente para transferir dados entre um cliente e um servidor. Ele fornece uma maneira fácil de recuperar dados de um URL sem ter que fazer uma atualização de página inteira. Isso permite que uma página da Web atualize apenas uma parte do conteúdo sem interromper o que o usuário esteja fazendo. XMLHttpRequest é usado constantemente na programação de AJAX.")  ou  [Fetch](https://developer.mozilla.org/pt-BR/docs/Web/API/Fetch_API) \- Para mitigar os riscos de pedidos HTTP de origem cruzada.

    Esse  [padrão de compartilhamento de origem cruzada](https://fetch.spec.whatwg.org/#http-cors-protocol)  é usado para habilitar solicitações de HTTP entre sites para:

    -   Invocações do  [`XMLHttpRequest`](https://developer.mozilla.org/pt-BR/docs/Web/API/XMLHttpRequest "XMLHttpRequest é uma API que fornece funcionalidade ao cliente para transferir dados entre um cliente e um servidor. Ele fornece uma maneira fácil de recuperar dados de um URL sem ter que fazer uma atualização de página inteira. Isso permite que uma página da Web atualize apenas uma parte do conteúdo sem interromper o que o usuário esteja fazendo. XMLHttpRequest é usado constantemente na programação de AJAX.")  ou API [Fetch](https://developer.mozilla.org/pt-BR/docs/Web/API/Fetch_API) em modo cross-site, tal como discutido acima.
    -   Web Fonts (para o uso de fontes através de cross-domain no  `@font`  do CSS),  [para que os servidores possam implantar fontes TrueType que só podem ser carregadas em vários sites e usadas por sites da Web autorizados a fazê-lo](https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements).
    -   [Texturas WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL).
    -   Frames de Imagens/video desenhados para um canvas usando  [drawImage](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage).
    -   Folhas de estilo (para acesso  [CSSOM](https://developer.mozilla.org/pt-BR/docs/MDN/Doc_status/API/CSSOM)).
    -   Scripts (para exceções desativadas).

    ---
    # AJAX 

    ## Exemplos de cenários de controle de acesso

    Aqui, apresentamos três cenários que ilustram como o Compartilhamento de Recursos entre Origens funciona. Todos estes exemplos usam o objeto  [`XMLHttpRequest`](https://developer.mozilla.org/pt-BR/docs/Web/API/XMLHttpRequest "XMLHttpRequest é uma API que fornece funcionalidade ao cliente para transferir dados entre um cliente e um servidor. Ele fornece uma maneira fácil de recuperar dados de um URL sem ter que fazer uma atualização de página inteira. Isso permite que uma página da Web atualize apenas uma parte do conteúdo sem interromper o que o usuário esteja fazendo. XMLHttpRequest é usado constantemente na programação de AJAX."), que pode ser utilizado para fazer requisições entre origens em qualquer navegador compatível.

    Os snippets JavaScript inclusos nessas seções (e instâncias executáveis do código no servidor que tratam corretamente essas requisições entre origens)  [podem ser encontradas "em ação" aqui](http://arunranga.com/examples/access-control/), e irão funcionar em navegadores que suportam [`XMLHttpRequest`](https://developer.mozilla.org/pt-BR/docs/Web/API/XMLHttpRequest "XMLHttpRequest é uma API que fornece funcionalidade ao cliente para transferir dados entre um cliente e um servidor. Ele fornece uma maneira fácil de recuperar dados de um URL sem ter que fazer uma atualização de página inteira. Isso permite que uma página da Web atualize apenas uma parte do conteúdo sem interromper o que o usuário esteja fazendo. XMLHttpRequest é usado constantemente na programação de AJAX.")  entre origens. Uma discussão sobre Compartilhamento de Recursos entre Origens a partir da  [perspectiva do servidor (incluindo snippets de código PHP) podem ser encontradas aqui](https://developer.mozilla.org/en-US/docs/Web/HTTP/Server-Side_Access_Control).

    ---
    # AJAX 

    ### Requisições simples

    Algumas requisições não desencadeiam um  [pré-envio CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests). Essas são denominadas “requisições simples” neste artigo, embora a especificação  [Fetch](https://fetch.spec.whatwg.org/ "The 'Fetch' specification") (que define CORS) não utilize este termo. Uma requisição que não desencadeia um [pré-envio CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests)—denominada “requisição simples”—é uma que atende todas as seguintes condições:

    -   Os únicos métodos permitidos são:
        -   [`GET`](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Methods/GET "A tabela de compatibilidade nesta página é gerada a partir de dados estruturados. Se você quiser contribuir com os dados, consulte https://github.com/mdn/browser-compat-data e envie-nos uma solicitação pull.")
        -   [`HEAD`](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Methods/HEAD "The documentation about this has not yet been written; please consider contributing!")
        -   [`POST`](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Methods/POST "The documentation about this has not yet been written; please consider contributing!")
    ---
    # AJAX 
    
    ### Requisições simples

    -   Fora os cabeçalhos definidos automaticamente pelo user agent (por exemplo,  [`Connection`](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Connection "The documentation about this has not yet been written; please consider contributing!"),  [`User-Agent`](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/User-Agent "O cabeçalho de requisição User-Agent contém uma string característica que permite o protocolo de rede do cliente identificar o tipo de aplicação, sistema operacional, fornecedor do software ou versão do software do agente de usuário do software solicitante."), ou [qualquer um dos outros cabeçalhos com nomes definidos na especificação Fetch como um “nome de cabeçalho proibido”](https://fetch.spec.whatwg.org/#forbidden-header-name)), os únicos cabeçalhos que são permitidos a serem manualmente definidos são [aqueles cujo a especificação Fetch define como sendo um “CORS-safelisted request-header”](https://fetch.spec.whatwg.org/#cors-safelisted-request-header), que são:
        -   [`Accept`](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Accept "The documentation about this has not yet been written; please consider contributing!")
        -   [`Accept-Language`](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Accept-Language "The documentation about this has not yet been written; please consider contributing!")
        -   [`Content-Language`](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Content-Language "The documentation about this has not yet been written; please consider contributing!")
        -   [`Content-Type`](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Content-Type "Em uma requisição POST, resultado de uma submissão de um formulário HTML, o Content-Type da requisição é especificado pelo atributo enctype do elemento <form> do HTML.")  (mas observe os requisitos adicionais abaixo)
        -   `[DPR](http://httpwg.org/http-extensions/client-hints.html#dpr)`
        -   `[Downlink](http://httpwg.org/http-extensions/client-hints.html#downlink)`
        -   `[Save-Data](http://httpwg.org/http-extensions/client-hints.html#save-data)`
        -   `[Viewport-Width](http://httpwg.org/http-extensions/client-hints.html#viewport-width)`
        -   `[Width](http://httpwg.org/http-extensions/client-hints.html#width)`
    ---
    # AJAX 
    
    ### Requisições simples

    -   Os únicos valores permitidos para o cabeçalho [`Content-Type`](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Content-Type "Em uma requisição POST, resultado de uma submissão de um formulário HTML, o Content-Type da requisição é especificado pelo atributo enctype do elemento <form> do HTML.") são:
        -   `application/x-www-form-urlencoded`
        -   `multipart/form-data`
        -   `text/plain`


    ---
    # AJAX

    Por exemplo, suponha que o conteúdo web no domínio `http://foo.example`  deseje invocar um outro conteúdo no domínio `http://bar.other`. Códigos como este podem ser usados com o Javascript hospedado em foo.example:

    ```js
    var invocation = new XMLHttpRequest();
    var url = 'http://bar.other/resources/public-data/';
       
    function callOtherDomain() {
      if(invocation) {    
        invocation.open('GET', url, true);
        invocation.onreadystatechange = handler;
        invocation.send(); 
      }
    }
    ```
    ---
    # AJAX

    Isso fará uma simples troca entre o cliente e o servidor, utilizando cabeçalhos CORS para o tratamento de privilégios.

    <div style="width: 100%;background: #ffff; max-width: 100%;padding: 10px;text-align: center;">
        <img src="https://mdn.mozillademos.org/files/14293/simple_req.png" style="max-height: 265px;" />
    </div>
       
    ---
    class: center, middle
    # Orientação a Objetos em JavaScript

    ---
    # Orientação a Objetos em JavaScript

    ---
    class: center, middle
    # Funções como objetos    

    ---
    # Funções como objetos
    
    ---
    class: center, middle
    # Funções de Alta Ordem     

    ---
    # Funções de Alta Ordem 

    ---
    class: center, middle
    #  API JS + HTML5

    ---
    #  API JS + HTML5

    ---
    class: center, middle
    # Transpiladores  

    ---
    # Transpilers / Source-to-source compiler

    Temos diversos sabores de  [linguagens de programação](https://pt.wikipedia.org/wiki/Lista_de_linguagens_de_programa%C3%A7%C3%A3o), para os mais variados ambientes e plataformas. De modo resumido temos linguagens de  [baixo nível](https://pt.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_baixo_n%C3%ADvel)e  [alto nível](https://pt.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_alto_n%C3%ADvel), ainda há as  [interpretadas](https://pt.wikipedia.org/wiki/Linguagem_interpretada),  [compiladas](https://pt.wikipedia.org/wiki/Linguagem_compilada)  e de  [script](https://pt.wikipedia.org/wiki/Linguagem_de_script).

    Cada linguagem tem características, sintaxes e paradigmas únicos, existem muitos paradigmas de programação. As vezes uma linguagem possui similaridades sintáticas com outras, porém com comportamentos completamente diferentes.

    > Saber a sintaxe de uma linguagem nunca vai garantir que você vai aprender outra linguagem com facilidade, há muitas armadilhas escondidas em sintaxes parecidas.

    Muitas vezes uma linguagem possui uma sintaxe ou paradigma complexo ou verboso demais para ser produtivo usar ela diretamente. Nesse ponto que entram os  _transpilers_.
    ---
    # Transpilers / Source-to-source compiler

    #### Tradução

    De maneira geral, a função de um  _transpiler_  é  _traduzir_  um código escrito em linguagem para um código de outra.

    Isso tem a capacidade de facilitar muito determinadas tarefas, pois no lugar de um código extremamente verboso e burocrático você pode usar uma sintaxe mais direta e agradável.

    _Transpilers_  também podem trazer novas funcionalidades para uma linguagem, como novos tipos primitivos, novas funções, fluxos… Não há um limite definido para isso.

    ---
    # Transpilers / Source-to-source compiler

    #### Ache o bug

    Devido a natureza de alguns  _transpilers_ ou das linguagens de destino, algumas coisas podem ser particularmente difíceis de serem feitas, como o  _debugging_.

    Devido a particularidades da linguagem de destino, achar a origem de um  _bug_pode ser um problema, afinal o código gerado não é o mesmo que você escreve.

    > Não é recomendado usar um  _transpiler_  sem ter um bom conhecimento da linguagem de destino.

    #### Transpiller, Linguagem, Superset…

    Não da para entrar em muitos detalhes, porém é importante saber que existem  _transpilers_  que são linguagens novas trazendo pouca coisa da linguagem destino. Também há aquelas que só adicionam  _coisas novas_, mantendo a sintaxe original ainda válida.

    Seja como for, é bom ler sobre o objetivo e filosofia do  _transpiler_  que você deseja usar. Esse tipo de coisa pode representar uma diferença muito grande no seu projeto.

    ---
    # Transpilers / Source-to-source compiler

    ### CoffeeScript

    ![](https://cdn-images-1.medium.com/max/1600/1*tI5IXkpztfhgR1hDenZvUg.png)

    [CoffeeScript](http://coffeescript.org/)  foi um dos primeiros  _transpilers_  para JavaScript a ganhar popularidade.

    Sua sintaxe e filosofia são baseadas no Ruby (comunidade de onde ele teve origem). Algumas de suas filosofias foram tão importantes que influenciaram algumas atualizações no  [ES2015](https://github.com/lukehoban/es6features#arrows).

    Atualmente se discute se ele ainda é popular, devido a algumas coisas que ele “resolvia” já estarem  [presentes no ES2015](https://robots.thoughtbot.com/replace-coffeescript-with-es6).

    ---
    # Transpilers / Source-to-source compiler

    ### TypeScript

    ![](https://cdn-images-1.medium.com/max/1600/1*o6YyWsTgUSsIc6LzSmQWaA.png)

    [TypeScript](https://www.typescriptlang.org/)  divide opiniões. Seu objetivo é permitir a tipagem estática do código JavaScript e com isso diminuir bugs e melhorar a leitura e manutenção do código, além disso ele adiciona recursos extras ao JavaScript

    Ele é um  _superset_  do JavaScript, com isso um código válido em JavaScript é um código válido para o TypeScript.


    ---
    # Transpilers / Source-to-source compiler

    ### Flow

    ![](https://cdn-images-1.medium.com/max/1600/1*KyKLFig1vSBPv8c4icD1pQ.png)

    [Flow](https://flowtype.org/)  é a alternativa para tipagem estática do Facebook. Muito popular com os usuários de  [React](https://facebook.github.io/react/), tem o mesmo objetivo que o TypeScript, porém ele se limita a isso apenas.

    Atualmente tem se  [aproximado bastante do Babel](http://babeljs.io/blog/2016/10/24/6.18.0)  para tornar o fluxo de trabalho mais eficiente e otimizado.

    ---
    # Transpilers / Source-to-source compiler

    ### Babel

    ![](https://cdn-images-1.medium.com/max/1600/1*jYRZ2B8kPsvjRPLjl7syYQ.png)

    [Babel](http://babeljs.io/)  é um caso a parte. Seu objetivo era fazer código escrito em ES6 virar ES5. Seu nome era  **6to5**  porém esse nome  [já não fazia sentido mediante](http://babeljs.io/blog/2015/02/15/not-born-to-die)  as atualizações constantes que o  _EcmaScript_  passou a ter.

    Hoje, além de tornar um código escrito em ES2015+ compatível com navegadores mais antigos, ele é uma plataforma na qual vários tipos de transformações podem ser feitas.

    Mais sobre essa mudança foi divulgada recentemente em  [The State of Babel](http://babeljs.io/blog/2016/12/07/the-state-of-babel).

    > Babel é sem dúvida uma das ferramentas mais populares no ecossistema JavaScript. Muito do que temos hoje se deve babel.

    #### Sujeira

    Nem tudo são flores no Babel, infelizmente ao transformar o código ES2015+ para ES5 muito lixo é gerado, e há perda de performance nesse código (devido a sujeira), TypeScript também tem esse problema.  
    Este é o preço a se pagar por tantos benefícios.

    A vantagem que o Babel tem frente aos outros  _transpilers_  é que com o passar o tempo você pode remover ele do projeto. Com atualizações constantes, cada vez mais navegadores tem  [suporte quase completo ao ES2015+](http://kangax.github.io/compat-table/es6/)

    ---
    # Transpilers / Source-to-source compiler

    ### JSX

    [JSX](https://facebook.github.io/jsx/)  é uma especificação/linguagem de marcação, semelhante ao XML, que permite gerar código para  [V-DOM](http://reactkungfu.com/2015/10/the-difference-between-virtual-dom-and-dom/).

    Ele é usado para facilitar a escrita desse tipo de código, que seria muito verboso sem o auxilio dele.
    
    ---
    # Transpilers / Source-to-source compiler
    ### Tipagem e JavaScript

    A discussão da necessidade de  [tipagem no JavaScript](https://medium.com/javascript-scene/you-might-not-need-typescript-or-static-types-aa7cb670a77b)  não é nova. Porém uma coisa é indiscutível: A checagem de tipos só vai acontecer em  _tempo de compilação_.

    Enquanto o código é compilado para JavaScript válido a checagem é feita e funciona muito bem, porém enquanto o código é executado (_runtime_) não existe essa checagem.

    > TypeScript e Flow são muito bons, mas não corrigem falhas de programação.


    ---
    class: center, middle
    # Babel  

    ---
    # Babel
    #### Instalando

    Iremos utilizar o  [Babelify](https://github.com/babel/babelify), um módulo  [npm](https://www.npmjs.com/)  feito para funcionar juntamente com o  [Browserify](http://browserify.org/), outro módulo que empacota todos os seus requires para serem usados no browser.

    Para instalar ambos, é necessário ter instalado em seu computador o  [Node.js](https://nodejs.org/), que juntamente instala o npm (Node Package Manager) ou Gerenciador de Pacotes Node.

    Navegue via terminal até a raiz do seu projeto e digite o comando abaixo:
    
    ```sh
    npm install --save-dev browserify babelify babel-preset-es2015
    ```

    ---
    # Babel

    O comando irá instalar o Browserify, Babelify e o plugin es2015 do Babel, responsável por cuidar da conversão de ES2015 para ES5, além de salvá-los na lista de devDependencies do seu  [package.json](https://docs.npmjs.com/files/package.json). Nesta versão do Babel (6) nenhum plugin é instalado por padrão, por isso precisamos instalar ele à parte, você pode encontrar a lista completa de plugins  [aqui](http://babeljs.io/docs/plugins/).

    ---
    # Babel
    ## Configurando

    ### Script

    Para configurarmos via script, abra o seu arquivo  [package.json](https://docs.npmjs.com/files/package.json), crie a sessão  [scripts](https://docs.npmjs.com/misc/scripts)  e nela vamos adicionar o código que irá transformar seu código ES2015 para ES5:

    ```json
    "build-browserify": "browserify ./src/meuarquivo.js -t \[ babelify --presets \[ es2015 \] \] -o ./dist/meunovoarquivo.js"
    ```

    ---
    # Babel
    ## Configurando

    Explicando um pouco mais sobre o código acima:

    ./src/meuarquivo.js – Este é o local do seu arquivo JS escrito nos padrões ES2015.

    -t \[ babelify –presets \[ es2015 \] \] – A option -t se refere à transform, que utiliza de módulos de transformação terceiros, neste caso o  [Babelify](https://github.com/babel/babelify). Passamos o módulo que iremos utilizar e passamos uma option para o módulo (–presets), nesta option listamos os  [plugins](http://babeljs.io/docs/plugins/)  que iremos utilizar do Babel, que será o es2015.

    -o ./dist/meunovoarquivo.js – A option -o se refere à output, aqui passamos o destino do nosso arquivo, que será gerado após a transformação.
    
    ---
    # Babel

    ### Grunt

    Podemos utilizar também o  [Grunt](http://gruntjs.com/), um Task Runner de Javascript, para realizarmos a transformação do arquivo. Para isso é necessário instalarmos mais um módulo npm, o  [grunt-browserify](https://www.npmjs.com/package/grunt-browserify)  (contando que você já tenha instalado em seu projeto os módulos  [grunt](https://www.npmjs.com/package/grunt)  e  [grunt-cli](https://www.npmjs.com/package/grunt-cli)).

    Novamente na raiz do seu projeto via terminal, digite o comando abaixo:

    ```sh
    npm install --save-dev grunt-browserify
    ```

    ---
    # Babel

    Após a instalação, vá em seu arquivo  [Gruntfile.js](http://gruntjs.com/sample-gruntfile) e adicione no config:

    ```json
    browserify: {
        dist: {
            options: {
                "transform": \[ \["babelify", { "presets": \["es2015"\] }\] \]
            },
            files: {
                './dist/meunovoarquivo.js': \['./src/meuarquivo.js'\]
            }
        }
    }
    ```

    Depois, carregue o módulo e registre uma task:

    grunt.loadNpmTasks('grunt-browserify');
    grunt.registerTask('default', \['browserify'\]);
   
    ---
    #Referências

    - https://developer.mozilla.org/pt-BR/docs/Learn/JavaScript/First_steps/O_que_e_JavaScript
    - https://classroom.udacity.com/courses/ud245
    - https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js
    
  </textarea>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/remark/0.14.0/remark.min.js"></script>
  <script>
    var slideshow = remark.create();
  </script>
</body>
</html>
